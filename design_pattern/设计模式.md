# 设计模式

## 六大设计原则

### 单一职责原则

单一职责定义：应该有且仅有一个原因引起类的变更。

### 里式替换原则

在继承关系中，只要有父类出现的地方子类就可以出现，并且替换成子类也不会产生任何错误或异常。反之则不然，有子类出现的地方，不一定能替换成父类。

这个原则很好地体现在工厂方法模式、模板方法模式、策略模式等有很好的展现。

### 依赖倒转原则

> High level modules should not depend upon low level modules.Both should depend upon abstractions.Abstractions should not depend upon details.Details should depend upon abstractions.

依赖倒转原则在Java中的体现：

- 模块间的依赖通过接口或抽象类产生，具体的实现类之间不产生直接的依赖关系
- 接口或抽象类不依赖于实现类
- 实现类依赖于接口或抽象类

更精简的定义是**面向接口编程**，是面向对象设计（OOD，Object Oriented Design）的关键之一。

### 接口隔离原则

> - Clients should not be forced to depend upon interfaces that they don't use.
> - The dependency of one class to another one should depend on the smallest possible interface.

接口隔离要求接口尽量细化，同时接口中的方法尽量要少。

与单一职责原则不同的是，接口隔离原则要求接口的方法数量，而单一职责更关注业务逻辑的划分。

### 迪米特法则

迪米特法则要求：一个雷应对自己需要耦合或调用的类了解得最少。

通俗地说，迪米特法则只关注耦合或者调用类提供的接口，不关注接口内部的实现如何复杂。

### 开闭原则

> Software entities like classes,modules and functions should be open for extension but closed for modifications.

类、模块、函数都应对扩展开发，对修改关闭。

我们平时对某些状态属性的处理常常会是多一个状态就多一个`if else`判断，其实这是违反了开闭原则的。

## 创建型设计模式

### 简单工厂模式（Simple Factory）

简单工厂模式又称为**静态工厂方法**模式（Static Factory Method）。

在简单工厂模式中，可以根据参数的不同返回不同类的实例。

简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。

#### 模式角色

- Factory：工厂角色

  > 工厂角色负责创建所有实例的内部逻辑

- Product：抽象产品角色，抽象类

  > 抽象产品角色是所创建所有对象的父类，负责描述所有实例所有的公共接口

- ConcreteProduct：具体产品角色， 实现`Product`抽象类的抽象方法。

  > 具体产品角色是创建目标，所有创建的对象都充当这个角色的某个具体类的实例

简单工厂模式类图如下：

![简单工厂模式类图](imgs/SimpleFactory.jpg)

#### 代码示例

抽象产品类`Product`：

```Java
// 抽象产品类
public abstract Class Product {
    // 抽象方法
    abstract void doSomething();
}
```

具体产品实现类`ConcreteProduct`（继承抽象产品类）：

```Java
// 具体产品实现类ConcreteProductOne
public class ConcreteProductOne extends Product {
    // 抽象方法实现
    public void doSomething() {
        // ConcreteProductOne 
    }
    
}

// 具体产品实现类ConcreteProductTwo
public class ConcreteProductTwo extends Product {
    
    public void doSomething() {
        // ConcreteProductTwo
    }
    
}
```

工厂类`Factory`：

```Java
// 工厂类
public class Factory {
    
    // 简单工厂模式又称 静态工厂方法 模式
    public static Product getConcreteProduct (String type) {
        // 也可用siwth case 
        if （type.equals("One")） {
            return new ConcreteProductOne();
        } else if (type.equals("Two")) {
            return new ConcreteProductTwo()；
        } else if{
            //······
        } else {
            // 找不到type对应的产品实现
            throw new Exception();
        }
    }
    
}
```

客户端调用：

```java
// 客户端调用
public class Client {
    
    public static void main(String[] args) throws Exception {
    	// 客户端不需要知道具体产品实现
        Product concreteProduct = Factory.getConcreteProduct("One");
        concreteProduct.doSomething();
    }
}
```

#### 应用场景

以下几种情况简单工厂模式：

- 工厂类负责创建的对象相对较少，较少的对象不会造成静态工厂方法中的业务逻辑太过复杂
- 客户端只需要传入工厂类的参数，不关心对象是如何创建的，甚至连具体实现类的类名都不需要关注

JDK类库中广泛应用了简单工厂模式，例如`java.text.DateFormat`工具类中获取时间格式的静态工厂方法：

```java
    public final static DateFormat getDateInstance() {
        return get(0, DEFAULT, 2, Locale.getDefault(Locale.Category.FORMAT));
    }

    public final static DateFormat getDateInstance(int style) {
        return get(0, style, 2, Locale.getDefault(Locale.Category.FORMAT));
    }

    public final static DateFormat getDateInstance(int style,
                                                 Locale aLocale) {
        return get(0, style, 2, aLocale);
    }
```



### 工厂方法模式（Factory Method）

工厂方法模式又被称为工厂模式，也称为虚拟构造器模式（Virtual Constructor）或者多态工厂模式（Polymorphic Factory）。

工厂方法模式中，工厂父类（抽象类）负责定义创建产品对象的公共接口（抽象方法），工厂子类负责生成具体的产品对象。

#### 模式角色

- Product ：抽象产品类
- ConcreteProduct：具体产品类
- Factory：抽象工厂类
- ConcreteFactory：具体工厂类

工厂方法模式类图如下：

![工厂方法类图](imgs/FactoryMethod.jpg)

#### 代码示例

抽象产品类（Product）和具体抽象产品实现类（ConcreteProduct）与简单工厂模式一样，有变化的是工厂类由普通类变成了抽象类，具体抽象产品的创建交由具体工厂类（ConcreteFactory）实现。

抽象产品类`Product`：

```Java
// 抽象产品类
public abstract Class Product {
    // 抽象方法
    abstract void doSomething();
}
```

具体产品实现类`ConcreteProduct`（继承抽象产品类）：

```Java
// 具体产品实现类ConcreteProductOne
public class ConcreteProductOne extends Product {
    // 抽象方法实现
    public void doSomething() {
        // ConcreteProductOne 
    }
    
}

// 具体产品实现类ConcreteProductTwo
public class ConcreteProductTwo extends Product {
    
    public void doSomething() {
        // ConcreteProductTwo
    }
    
}
```

工厂抽象类`Factory`：

```java
// 工厂类变为工厂抽象类
public abstract Class Factory {
    
    // 抽象方法， 将具体产品类的创建交由具体的工厂实现类
    abstract Product create();
    
}
```

工厂实现类`ConccreteFactory`:

```java
// 具体工厂实现类ConcreteFactoryOne
public Class ConcreteFactoryOne extends Factory {
    public Product create() {
        return new ConcreteProductOne();
    }
}

// 具体工厂实现类ConcreteFactoryTwo
public Class ConcreteFactoryTwo extends Factory {
    public Product create() {
        return new ConcreteProductTwo();
    }
}
```

客户端调用：

```java
class Client {
    public static void main(String[] args) {
        // 调用ConcreteProductOne
        Factory factoryOne = new ConcreteFactoryOne();
        factoryOne.doSomthting();
        
        // 调用concreteProductTwo
        Factory factoryTwo = new ConcreteFactoryTwo();
        factoryTwo.doSomething();
    }
}
```

#### 应用场景

工厂方法模式适用于以下场景：

- 一个类不知道它所需要的对象的类
- 一个类通过子类来指定要创建的对象
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可以将具体工厂实现类的类名存储在配置文件或者数据库中

JDBC中有使用工厂方法：

```java
Connection conn=DriverManager.getConnection("jdbc:microsoft:sqlserver://localhost:1433; DatabaseName=DB;user=sa;password=");
Statement statement=conn.createStatement();
ResultSet rs=statement.executeQuery("select * from UserInfo");

@CallerSensitive
public static Connection getConnection(String url)
    throws SQLException {

    java.util.Properties info = new java.util.Properties();
    // 反射获取具体工厂子类
    return (getConnection(url, info, Reflection.getCallerClass()));
}

```

#### 与简单工厂模式对比

工厂方法模式是简单工厂模式的进一步抽象和推广。工厂方法模式使用了面向对象的多态性，更符合"开闭原则"。

在工厂方法模式中，核心的工厂类不再负责具体产品类的创建，而是将创建的工作交给具体工厂子类去做。

### 抽象工厂模式（Abstract Factory）

抽象工厂模式提供了一个创建一系列相关或相互依赖对象的接口，而且无需指定它们具体的类。

#### 模式结构

- `AbstractFacotry`：抽象工厂
- `ConcreteFactory`：具体工厂
- `AbstractProduct`：抽象产品
- `Product`：具体产品

抽象工厂模式类图如下：

![抽象工厂模式类图](imgs/AbstractFactory.jpg)

#### 代码示例 // todo

// todo 

#### 应用场景

适合抽象工厂模式的情况

- 系统不依赖于产品类实例如何被创建、组合和表达细节
- 系统中有多于一个的产品族，且每次只使用一个产品族
- 属于同一个产品族的产品将在一起使用，这种约束必须在系统的设计中体现出来
- 系统提供一个产品类的库，所有产品以同样的接口出现，客户端不依赖于具体实现

#### 三种工厂模式比较

- 如果抽象工厂模式中每一个具体工厂类只创建一个产品对象，意即只存在一个产品等级结构时，抽象工厂模式转换成工厂方法模式
- 抽象工厂模式与工厂方法模式最大的区别在于，工厂方法模式针对于一个产品，而抽象工厂模式需要面对多个产品
- 当工厂方法模式中抽象工厂与具体工厂合并，提供了一个统一的工厂来创建产品，并且这个创建产品的方法是静态方法，此时工厂方法模式转换成简单工厂模式

### 单例模式（Singleton）

单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。

在单例模式的实现过程中，需要注意以下三点：

- **私有的**单例类的构造函数
- 提供一个自身的静态**私有**成员变量
- 提供一个**公有的**静态工厂方法

#### 模式结构

- `Singleton`：单例

单例模式类图如下：

![单例模式类图](imgs/Singleton.jpg)

#### 代码示例

##### 饿汉模式实现

```Java
// 饿汉模式
public class Singleton {
    // 自身的私有成员变量
    private static Singleton instance = new Singleton();
    
    // 私有的构造函数 
    private Singleton() {
    }
    
    // 公有的静态方法
    public static getInstance() {
        return instance;
    }
}
```

通过static静态初始化的方式，在`Singleton`类第一次被加载的时候就有一个`Singleton`实例被创建出来了。这样能保证在第一次想要使用该对象时，就已经初始化完毕了。

饿汉模式创建的单例由于在类被加载时就创建出来了，所以也避免了线程安全问题。

饿汉模式的弊端：

饿汉模式在类被加载时就会被实例化，这样虽然保证了线程安全，但是如果这个实例没被用到的话，有可能会造成不必要的内存消耗。此外如果这个类被多次加载也会多次被实例化。

**静态内部类方式**和**懒汉方式**实现就能解决这个问题。

##### 静态内部类方式实现

```java
public class Singleton {
    // 静态内部类中初始化自身的成员变量
    private static class StaticInnerSingleton {
        private static final Singleton INSTANCE = new Singleton();
    }
    // 私有的构造方法
    private Singleton() {
    }
    // 对外提供的静态方法
    public static Singleton getInstance() {
        return StaticInnerSingleton.INSTANCE;
    }
}
```

静态内部类方式加载单例同样使用了`classLoader`的类加载机制来保证单例。

与饿汉模式不同的是，饿汉模式是只要`Singleton`被加载了，instance就会被实例化，而在静态内部类实现方式中，`StaticInnerSingleton`只有在`getInstance()`被调用时才会被装载，进而实例化instance。

##### 懒汉方式实现

- synchronized加方法锁方式

```java
public class Singleton {
    // 私有静态自身成员变量
    private static Singleton instance = null;
    // 私有构造函数
    private Singleton() {}
    
    // 公有静态方法,方法加锁能保证线程安全
    public static synchronized Singleton getInstance() {
        // 在对象被调动时才初始化
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```



- 双重检查方式

```java
// 双重检查方式
public class Singleton {
    // 静态的私有自身成员变量
    private volatile static Singleton instance = null;
   	// 私有的构造方法
    private Singleton() {
    }
    // 静态的获取实例的方法（双重安全检验）
    public static Singleton getInstance() {
        if (instance == null) {
            synchronized (this) {
                if (instance == null) {
                   instance = new Singleton(); 
                }
            }
        }
        return instance;
    }
}
```

##### 枚举方式实现

```java
public enum Singleton {
    INSTANCE;
    
    Singleton() {
    }
}
```

枚举方式实现不仅能避免多线程同步的问题，还能防止反序列化重新创建新的对象。

#### 应用场景

以下情况可以适用单例模式：

- 系统只需要一个实例对象，比如系统要求提供一个唯一的序列号生成器，或者多实例消耗资源过多而需要单例
- 客户端调用类的单个实例只允许适用一个公共访问点，除了该访问点不能通过其他路径访问该实例
- 在一个系统中要求一个类只有一个实例时才应当适用单例模式



### 原型模式（Prototype）

### 建造者模式（Builder）

## 结构型设计模式

### 适配器模式（Adapter）

### 桥接模式（Bridge）

### 组合模式（Composite）

### 装饰模式（Decorator）

### 外观模式（Facade）

### 代理模式（Proxy）

### 享元模式（Flyweight）

## 行为型设计模式

### 责任链模式（Chain of Responsibility）

### 命令模式（Command）

### 迭代器模式（Iterator）

### 观察者模式（Observer）

### 状态模式（State）

### 策略模式（Strategy）

### 模板方法模式（Template Method）

模板方法模式是带有模板功能的模式，组成模板的抽象方法被定义在父类中。

由于这些方法是抽象方法，所以仅通过查看父类只能看到方法是如何调用的，并不能看到方法如何实现。实现这些抽象方法的是子类，同一个抽象方法，在不同子类中实现不同的处理，当父类的模板方法被调用时程序行为也不会不同。

像这样**在父类定义处理流程，在子类具体实现处理细节**的模式就被称为模板方法模式。

#### 模式结构

- 抽象类`AbstractClass`：负责给出一个算法的轮廓或骨架。由模板方法和基本方法构成。`AbstractClass`角色不仅仅实现模板方法，还负责声明在模板方法中所使用到的抽象方法。
  - 模板方法：定义了算法的骨架，调用抽象类中包含的抽象方法。
  - 基本方法：模板方法算法中的步骤，包含以下几种类型：
    - 抽象方法：在抽象类中定义，子类负责具体实现
    - 具体方法：在抽象类中已经实现，在子类中可以继承或重写
    - 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种
- 具体子类`ConcreteClass`：实现抽象类中定义的抽象方法和钩子方法。

模板方法结构如图：

![模板方法类图](imgs/TemplateMethod.png)

#### 代码示例

- 抽象类`AbstractClass`

```java
public abstract class AbstractClass {

    // 具体方法
    public void specifiedMethod() {
        System.out.println("抽象类-基本方法-具体方法");
    }

    // 抽象方法1
    public abstract void abstractMethod1();

    // 抽象方法2
    public abstract void abstractMethod2();

    // 模板方法
    // 这里使用final修饰:表明该模板方法不能被重写
    public final void templateMethod() {
        System.out.println("抽象类-模板方法");
        this.specifiedMethod();
        this.abstractMethod1();
        this.abstractMethod2();
    }

}
```

- 具体子类

```java
public class ConcreteClassFirst extends AbstractClass {

    @Override
    public void abstractMethod1() {
        System.out.println("具体子类1, 具体方法abstractMethod1");
    }

    @Override
    public void abstractMethod2() {
        System.out.println("具体子类1, 具体方法abstractMethod2");
    }
}
```

```java
public class ConcreteClassSecond extends AbstractClass {

    @Override
    public void abstractMethod1() {
        System.out.println("具体子类2, 具体方法abstractMethod1");
    }

    @Override
    public void abstractMethod2() {
        System.out.println("具体子类2, 具体方法abstractMethod2");
    }
}
```

- 客户端类

```java
public class TestTemplateMethod {
    public static void main(String[] args) {
        // 生成具体实例 
        // 这里很好地体现了"里式替换原则":在继承关系中，只要有父类出现的地方子类就可以出现，并且替换成子类也不会产生任何错误或异常。反之则不然，有子类出现的地方，不一定能替换成父类。
        AbstractClass templateFirst = new ConcreteClassFirst();
        AbstractClass templateSecond = new ConcreteClassSecond();
        // 调用模板方法
        templateFirst.templateMethod();
        templateSecond.templateMethod();
    }
}
```

#### 应用

`java.io`包下的`InputStream`和`OutputStream`类就使用了模板方法模式。

```java
public abstract class InputStream implements Closeable {
    //  .... 其余代码略
    
    // 抽象方法
    public abstract int read() throws IOException;
    
    // 模板方法：给出算法
    // 这里模板方法可以被重写
    public int read(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if (off < 0 || len < 0 || len > b.length - off) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return 0;
        }
		
        // 抽象方法，由子类负责具体实现
        int c = read();
        if (c == -1) {
            return -1;
        }
        b[off] = (byte)c;

        int i = 1;
        try {
            for (; i < len ; i++) {
                c = read();
                if (c == -1) {
                    break;
                }
                b[off + i] = (byte)c;
            }
        } catch (IOException ee) {
        }
        return i;
    }
}
```

`outputStream`抽象类的`write()`同理。

```java
public abstract class OutputStream implements Closeable, Flushable {
    // ....其余代码略
    
    // 抽象方法
    public abstract void write(int b) throws IOException;
    
    // 模板方法
    public void write(byte b[], int off, int len) throws IOException {
        if (b == null) {
            throw new NullPointerException();
        } else if ((off < 0) || (off > b.length) || (len < 0) ||
                   ((off + len) > b.length) || ((off + len) < 0)) {
            throw new IndexOutOfBoundsException();
        } else if (len == 0) {
            return;
        }
        for (int i = 0 ; i < len ; i++) {
            // 抽象方法
            write(b[off + i]);
        }
    }    
}
```

#### 优点

模板方法模式在父类中的模板方法中就编写了算法，无需在子类中再编写算法。

这也是**模板方法模式中`AbstractClass`类不能替换成接口**的原因：父类的模板方法中需要编写算法。

#### 相关的设计模式

##### 工厂方法模式

工厂方法模式是将模板方法模式应用于生成实例的典型例子。

##### 策略模式

策略模式与模板方法模式在封装程序行为的操作上相反。

模板方法模式**使用子类继承改变程序的行为**，模板方法模式在父类中定义程序的算法（处理流程），在子类中决定具体的处理。

策略模式**使用委托改变程序的行为**，策略模式用子类实现实现程序的算法。**策略模式的`AbstracClass`可以用接口代替**。


### 中介者模式（Mediator）

### 备忘录模式（Memento）

### 解释器模式（Interpreter）

### 访问者模式（Visitor）

## 参考

- [图说设计模式](https://design-patterns.readthedocs.io/zh_CN/latest/index.html)

- 《图解设计模式》

- 《设计模式之禅》