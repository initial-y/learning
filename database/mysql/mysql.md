# MySQL

## SQL语句的执行过程

## MySQL存储引擎

### InnoDB

MySQL默认事务型引擎。多于用处理短期事务，短期事物大部分情况下能正常提交，很少被回滚。

### MyISAM

MySQL5.1及之前版本的默认引擎。提供了全文索引、压缩、空间函数等特性。**但MyISAM不支持事务和行级锁**，并且在崩溃后无法安全恢复。

### Archive

### Blackhole

### CSV

### Federated

### Memory

### Merge

### NDB集群

## 是什么影响了数据库性能

1. 超高的QPS和TPS

   - QPS：每秒钟处理的查询量

   - 风险：效率底下的SQL

2. 大量的并发和超高的CPU使用率

   - 大量的并发： 数据库连接数被占满（max_connections默认为100）

   - 超高的CPU使用率：因CPU资源耗尽而出现宕机

3. 磁盘IO

   - 磁盘IO性能突然下降（解决办法：使用更快的磁盘设备）
   - 其他大量消耗磁盘性能的计划任务（解决办法：调整计划任务）

4. 网卡流量

   - 网卡IO被占满

### 如何避免无法连接数据库的情况

1. 减少从服务器的数量
2. 进行分级缓存
3. 避免使用`select *`进行查询
4. 分离业务网络和服务网络

### 关于大表

什么样的表可以称之为大表：

- 记录行数巨大，大表超过千万行
- 表数据文件巨大，表数据文件超过10G

大表对查询的影响：

- 慢查询：很难再一定时间内过滤出所需要的数据

大表对DDL操作的影响

- 建立索引需要很长时间
  - MySQL版本< 5.5 建立索引会锁表，版本 >=5.5 不会锁表但是会引起主从延迟
- 修改表结构需要长时间锁表
  - 会造成长时间的主从延迟         
  - 影响正常的数据操作.

如何处理数据库中的大表

- 分库分表把一张大表分成多个小标
  - 分表主键的选择
  - 分表后跨分区数据的查询和统计

- 大表历史数据归档，减少对业务的影响
  - 归档时间的选择
  - 如何进行归档

## 事务

事务是数据库系统区别于其他一切文件系统的重要特性之一。

事务是一组具有原子性的SQL语句，或是一个独立的工作单元 (全部完成或者全部失败)。

### 事务的四大特性

1. 原子性(atomicity):一个事务必须被视为一个不可分割的最小工作单元，整个事务中的所有操作要么全部提交成功，要么全部失败，对于一个事务来说，不可能只执行其中的一部分操作

2. 一致性(consistency)：一致性是指事务将数据库从一种一致性状态转换到另一种一致性状态，在事物开始之前和事务结束后数据库中的数据的完整性没有被破坏

3. 隔离性(isolation)：隔离性要求一个事务对数据库中数据的修改，在未提交完成前对其他事务是不可见的

   >  SQL标准中定义的4种隔离级别：
   >
   > 1. 未提交读（READ UNCOMMITED）：隔离性低，并发性高
   > 2. 已提交读（READ COMMITED）：
   > 3. 可重复读（REPEATABLE READ）：innodb的默认隔离级别
   > 4. 可串行化（SERILIZABLE)：隔离性高，并发性低
   >
   > 上述四种隔离级别：隔离性由低到高，并发性由高到低

4. 持久性(durability)：一旦事务提交，则其所做的修改就会永久保存到数据库中。此时即使系统崩溃，已提交的修改数据也不会丢失。(磁盘不损坏的情况下)

### 并发事务带来的问题

1. 脏读（dirty read）：当一个事务正在访问数据并且对数据进行了修改，而这种修改还没有提交到数据库中，这时另外一个事务也访问了这个数据，然后使用了这个数据。因为这个数据是还没有提交的数据，那么另外一个事务读到的这个数据是“脏数据”，依据“脏数据”所做的操作可能是不正确的。

2. 丢失修改（Lost to modify）: 指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。	

   例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-2=18，然后事务2也修改A=A-1，最终结果A=19，事务1的修改被丢失。

3. 不可重复读（Unrepeatableread）：指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。
4. 幻读（Phantom read）：幻读与不可重复读类似。它发生在一个事务（T1）读取了几行数据，接着另一个并发事务（T2）插入了一些数据时。在随后的查询中，第一个事务（T1）就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。

不可重复读和幻读的区别：

不可重复读的重点是修改比如多次读取一条记录发现其中某些列的值被修改，幻读的重点在于新增或者删除比如多次读取一条记录发现记录增多或减少了。

### 事务的隔离级别

#### 未提交读

未提交读（READ UNCOMMITTED），事务中的修改，即使没有提交，对其他事务也都是可见的。事务可以读取未提交的数据，这也被称为脏读（Dirty Read）。

这个级别会带来许多问题，然而性能却没有比其他级别好太多，在实际应用中很少使用。

#### 提交读

提交读（READ COMMITTED)，事务从开始直到提交之前，所做的任何修改对其他事务不可见。提交读有时候也被称为**不可重复读**（nonrepeatable read），两次执行同样的查询可能会得到不一样的结果。

除MySQL之外的大多数数据库系统的默认级别就是提交读。

#### 可重复读

可重复读（REPEATABLE READ)，该级别保证了在同一事务中多次读取同样的记录结果是一致的，解决了脏读的问题。

可重复读理论上没有解决幻读（phantom read）问题。幻读，当事务在读取某个范围内的记录时，另外一个事务又在该范围内插入了新的记录，导致之前的事务再次读取该范围的记录时，会产生幻行（phantom row）。

InnoDB和XtraDB存储引擎通过**多版本并发控制**（MVCC，multipleversion concurrency control）解决了幻读问题。

可重复读是MySQL的默认事务隔离级别。

#### 可串行化

可串行化（SERIALIZABLE），事务的最高隔离级别，通过强制事务**串行执行**来避免幻读问题。

可串行化还在读取的每一行数据都加上锁，所以可能会导致大量的超时和锁争夺的问题。实际应用中很少使用到这个隔离级别，在少数急需确保数据一致性且没有并发的情况下可以考虑使用。

### 大事务

运行时间比较长，操作的数据比较多的事务

- 锁定太多数据，造成大量阻塞和超时
- 回滚所需时间比较长
- 执行时间长，主从延迟

处理大事务

- 避免一次处理太多的数据
- 移除事务中不必要的select操作

### 多版本并发控制

MVCC，可以视为是行级锁的一个变种，但在很多情况下都避免了加锁的操作，比起行级锁开销更低。

不同数据库（MySQL，Oracle，PostgreSQL），都实现了MVCC，大都实现了非阻塞操作，写操作也只需要锁定必需的行。

#### InnoDB的MVCC

通过每行记录后面保存两个隐藏列来实现。一个隐藏列保存行的创建时间，一个保存行的过期时间（删除时间）。这个时间值并不是真的时间值，而是系统版本号。

每开始一个新事务，系统版本号都会自动递增。事务开始时刻的系统版本号会作为事务的版本号，用来和查询到的每行记录的版本号进行比较。

在REPEATABLE READ事务隔离级别下的MVCC:

- select

   InnoDB会以一下两个条件检查每行记录：

  1. InnoDB只会查找版本遭遇当前事务版本的数据行，这样可以保证事务读取的行是在事务开始前已经存在的（或者是被事务自身插入或修改过的）。
  2. 行的删除版本要么未定义，要么大于当前事务的版本号。这可以保证事务读取的行，在事务开始前未被删除。

- insert

  InnoDB为新插入的每一行保存当前系统的版本号作为行版本号。

- delete

  InnoDB为删除的每一行保存当前系统的版本号作为行删除标志。

- update

  InnoDB为插入一行记录，保存当前系统版本号作为行版本号，同时保存当前系统版本号到原来的行作为行删除标志。

保存的这个两个额外的系统版本号可以使数据库的大多数操作都不必加锁。

MVCC只能在可重复读和提交读两个事务隔离级别下工作。可串行化不需要，未提交读总是读取最新的数据。

## MySQL锁

在实际的数据库系统中，MySQL通过锁防止其他用户读取同一数据。

### 锁粒度

选择合适的锁粒度是一种提高共享资源并发性的方式。尽量锁定只需要修改的那部分数据，而不是所有资源。锁定的资源越少，并发性越好。

但是给资源加锁也需要耗费资源。锁的各种操作（获得锁，释放锁，检查锁是否解除。。）都会增加系统的开销。

锁策略就是在锁的开销和数据安全性之间取得平衡。在MySQL中，每种存储引擎都可以实现自己的锁策略和锁粒度。

表级锁和行级锁是MySQL最重要的两种锁策略。

#### 表级锁

表锁是MySQL中最基本，也是**开销最小的锁策略**。

表锁会锁定整张表。用户在对表进行操作（插入、删除、更新等）前，需要先获得锁，这会阻塞其他用户对该表的**所有读写操作**。

需要注意的是，只有在没有写锁时，其他读取的用户才能获取读锁，读锁之间是不会相互阻塞的。

此外，写锁有着比读锁更高的优先级。写锁的请求可能可能会被插入到读锁的前面，反之读锁是不能插入到写锁的前面的。

虽然储存引擎可以管理自己的锁，但是MySQL还是会使用各种有效的表锁来实现自己的目的。比如就算使用的innoDB存储引擎，但是MySQL还是会为诸如`ALTER TABLE`之类的语句使用表锁，而忽略存储引擎的锁机制。

#### 行级锁

行级锁可以最大程度地支持并发处理，同时也带来了最大的锁开销。

InnoDB和XtraDB存储引擎中实现了行级锁。行级锁只在存储引擎层实现，MySQL服务器层没有实现。

### 死锁

死锁是指两个或者多个事务在同一资源上相互占用，并请求锁定对方占用的资源进而导致恶心循环的现象。

当多个事务试图以不同的顺序锁定资源时，就可能会产生死锁。多个事务同时锁定同一资源，也可能会产生死锁。

为了解决死锁，数据库系统一般会实现各种死锁检测和死锁超时机制。innoDB存储引擎处理死锁的方法是，将持有最少行级排它锁的事务进行回滚。

死锁发生后，只有部分或者完全回滚其中的一个事务，才能打破死锁。对于事务型的系统，在应用程序设计时必须考虑如何处理死锁。处理死锁后，大多数情况下只需要重新执行因死锁回滚的事务即可。

## MySQL高性能优化

### 索引

### 

## 