# 数据结构

## 数组

>  数组(Array)是一种**线性表**数据结构。它用一组**连续的内存空间**，来存储一组具有**相同类型的数据**。

### 线性表

> 线性表(Linear List)表示数据排成一条线一样的结构。每个线性表伤的数据最多只有前和后两个方向。数组，链表，队列，栈等都是线性表结构。
#### 线性表
![线性表](https://static001.geekbang.org/resource/image/b6/77/b6b71ec46935130dff5c4b62cf273477.jpg)

#### 非线性表
> 与线性表对应的结构是**非线性表**，比如二叉树，堆，图等结构。在非线性表中，数据之间的排列并不是简单的前后关系。

![非线性表](https://static001.geekbang.org/resource/image/6e/69/6ebf42641b5f98f912d36f6bf86f6569.jpg)

#### 连续的内存空间和相同的类型数据
正因为有了这两个特性，数组才有了**随机访问**的特性。但是也正式因为这两个特性，也使得数组的删除/插入操作变得非常低效。如果想要**保持数组的连续性**，在数组中插入或删除一个数据会做大量的数据迁移工作。
### 寻址公式
![数组连续的地址](https://static001.geekbang.org/resource/image/98/c4/98df8e702b14096e7ee4a5141260cdc4.jpg)
拿一个长度为10的int类型数组举例：

```java
int[] a = new int[10];
```
图中，假如计算机给数组a[10]分配了一块**连续的内存空间**1000~1039，其中，内存块的首地址为base_address = 1000。  
我们知道计算机会给每个内存单元分配一个地址，计算机通过地址来访为内存中的数据。  
当计算机需要随机访问数组中的某个元素时，首先会通过下面的**寻址公式**，计算出该元素存储的内存地址：
```java
a[i]_address = base_address + i * data_type_size;
```
上例中存储的是int类型的数据，所以data_type_size是4个字节。  
#### 数组和链表的区别
纠正一种不准确的说法：
>  数组适合查找，查找的时间复杂度为O(1)；链表适合插入和删除，插入和删除的时间复杂度为O(1)。  

事实上，数组虽然适合查找操作，但是查找的时间复杂度并不为O(1)。即便是排好序的数组，用二分查找法查找，时间复杂度也是`$O(logn)$`。  
对数组准确的描述应该是：数组支持随机访问，**根据下标随机访问**的时间复杂度是O(1)。
#### 为什么数组下标要从0开始编号
从数组的内存模型来看，**下标**最确切的定义应该是**偏移(offset)**。上面讲到，如果用a来表示素组的首地址，a[0]就表示便宜k个data_type_size的地址，偏移为0的地址也就是**首地址**，而a[k]就表示偏移k个data_type_size的位置，所以a[k]的内存地址可以用如下公式来计算:
```java
a[k]_address = base_address + K * data_type_size
```
假如数组从1开始计数，那么a[k]的内存地址就会变成:
```java
a[k]_address = base_address + (K - 1) * data_type_size
```
对比而言，如果数组下标从1开始编号，每次随机访问数组元素都多了一次剑法运算，对CPU来说就多了一次减法指令。
### 数组的插入和删除
#### 插入
假设存在一个数组长度为n，如果我们要将一个数据插入到数组中的第k个位置(k<n)。在保证之前顺序的情况下，为了把第k个位置挪出来给新插入的数据，我们需要将第k~n部分的数据都顺序的往后挪一位。  
最好情况，如果是在数组的末尾插入元素，此时不需要移动数据，此时的时间复杂度为O(1)。  
最坏情况，如果实在数组的开头插入元素，此时所有的数据都需要往后挪一位，最坏的时间复杂度为O(n)。由于往每个位置插入数据的概率是一样的，所以插入数据的平均时间复杂度为(1+2+···n)/n = O(n)。  
***
如果数组中存储的数据不需要任何规律，只是作为数据存储的一个集合。在这种情况下，我们可以避免大规模的数据转移，直接将第k位的数据挪到数组元素的最后，然后将插入的元素直接放入第k位。
![避免大规模数据迁移的数组插入](https://static001.geekbang.org/resource/image/3f/dc/3f70b4ad9069ec568a2caaddc231b7dc.jpg)
在上述场景中，在第k位插入元素的时间复杂度就会降为O(1)。这种处理思想在**快速排序**中有很好的应用。
#### 删除
在保证内存连续性的情况下，如果我们要删除第k个位置的数据，也需要搬移大量的数据。  
与插入类似，删除末尾元素，时间复杂度为O(1)；删除开头的元素，最坏时间复杂度为O(n);平均时间复杂度为O(n)。  
在某些场景下，我们并不一定非得追求数组中数据的连续性。如果我们将多次删除操作集中在一起执行，删除的效率会高很多。
![数组删除操作](https://static001.geekbang.org/resource/image/b6/e5/b69b8c5dbf6248649ddab7d3e7cfd7e5.jpg)
在图中，假设数组a[10]存储了8个元素：a到h。我们依次删除a,b,c3个元素。为了避免d,e,f,g,h这几个数据被搬移3此，我们可以先记录下已经删除的数据a,b,c。每次的删除操作并不是真正的搬移数据，而只是记录数据已被删除。当数组真正**没有更多空间存储数据**时，我们再触发一次真正的删除操作，这样就大大减少了删除操作导致的数据搬移。  
上面的思想正是**JVM标记清除垃圾回收算法**的核心思想。
### 数组访问越界的问题
- java：抛出java.lang.ArrayIndexOutOfBoundException;
- C: 下面代码会无限循环（c语言中，只要不是访问受限的内存，其他内存都可以自由访问）
```c
int main(int argc, char* argv[]){
    int i = 0;
    int arr[3] = {0};
    for(; i<=3; i++){
        arr[i] = 0;
        printf("hello world\n");
    }
    return 0;
}
```
根据寻址公式，越界的元素a[3]会被定位到某块不属于数组的内存地址上，而这个地址正好是存储变量i的内存地址，那么a[3]=0就等同于i=0，所以会导致循环内代码停不下来。  
数组越界在c语言中是一种未决行为，并没有规定数组访问越界时编译器该如何处理。因为访问数组的本质就是访问一段连续内存，只要数组通过偏移计算得到的内存地址时可用的，那么程序就有可能不报任何错误。

### 数组与容器（ArrayList）的选择

数组对应的容器类ArrayList无法储存基本数据类型，需要封装成包装类，而自动装箱、拆箱（AutoBoxing、Unboxing）会有一定的性能开销，如果追求极致的性能，可以优选数组。

如果数据大小是确定的，并且用不到ArrayList类的绝大部分方法，可以选择数组。

多维数组用数组（`int [] []`）体现比容器（`ArrayList<ArrayList>`）更为直观。

## 链表

>  链表也是一种**线性表**，但是在存储方面不会按线性的存储顺序存储数据，而是在每一个结点里存储指向下一个节点的指针（Pointer）。

### 数组与链表的比较

从底层的存储结构来区分:

> 数组需要一块**连续的内存空间**来存储数据，对内存要求比较高。注意这里要求内存空间必须是**连续的**，假如我们要申请一个100MB大小的数组，不管内存有多大剩余空间，只要没有连续的100MB大小内存，都是会申请失败的。
>
> 相比而言，链表不需要连续的内存空间。链表通过**指针**将一组零散的内存块串起来使用。如果我们申请的是100MB大小的链表，只要内存有100MB大小（不管它是否连续）就可以。  

下面是数组和链表存储结构对比图：
![数组链表的存储结构对比](https://static001.geekbang.org/resource/image/d5/cd/d5d5bee4be28326ba3c28373808a62cd.jpg)

### 链表结构

#### 单链表
![单链表结构示意图](https://static001.geekbang.org/resource/image/b9/eb/b93e7ade9bb927baad1348d9a806ddeb.jpg)
##### 结点和后继指针
- 结点： 上面说链表通过指针将一组零散的内存块串在一起。这里的内存块就称之为链表的**结点**
- 后继指针： 每个链表的结点除了存储数据之外，还需要记录链上下一个结点的地址。这个记录下个结点地址的指针就叫做**后继指针next**。

##### 头结点和尾结点
- 头结点： 链表的第一个结点，用来记录链表的基地址。有了头结点就可以遍历得到整条链表。
- 尾结点： 链表的最后一个结点。尾结点的指针不是指向下一个结点，而是指向一个**空地址NULL**，表示这是链表上最后一个结点。

##### 链表的查找、插入和删除操作
- 链表的插入和删除

![链表的插入和删除](https://static001.geekbang.org/resource/image/45/17/452e943788bdeea462d364389bd08a17.jpg)
在进行数组的插入和删除时，因为要保证内存数据的连续性，需要做大量的搬移操作，数组插入和删除的时间复杂度为O(n)。  
而在对链表插入和删除时，只需考虑相邻结点指针的变化，时间复杂度为O(1)。
-  链表的随机访问

根据寻址公式，数组根据下标随机访问的时间复杂度为O(1)。  
而对链表而言，因为链表的数据并不是连续存储的，随机访问时，我们只能根据指针一个一个结点地遍历。随机访问链表的时间复杂度为O(n)。

#### 循环链表
> 循环链表是一种特殊的单链表。循环链表和单链表的区别就在与尾结点。单链表的尾结点指向一个**空地址**，而循环链表的尾结点指向链表的**头结点**。 

![循环链表结构图](https://static001.geekbang.org/resource/image/86/55/86cb7dc331ea958b0a108b911f38d155.jpg)
与单链表相比，循环链表的优点是：从链尾到链头比较方便。当处理的数据具有环型的结构特点时（比如[约瑟夫问题](https://zh.wikipedia.org/wiki/%E7%BA%A6%E7%91%9F%E5%A4%AB%E6%96%AF%E9%97%AE%E9%A2%98)），就适合使用循环链表的结构。

此外，如果我们想要保存数量固定的最新数据时通常可以选择使用循环

####  双向链表
> 双向链表，每个结点不只有一个**后继指针next**指向后面的结点，还有一个**前驱指针prev**指向前面的结点。

![双向链表结构图](https://static001.geekbang.org/resource/image/cb/0b/cbc8ab20276e2f9312030c313a9ef70b.jpg)
除了内存块之外，双向链表需要额外的两个空间来存储后继结点和前驱结点的地址。存储同样多的数据，双向链表比单链表更占用内存空间。  

此外，双向链表在进行增加或删除操作时需要改变更多指针的指向。

#### 链表的操作

##### 删除和插入操作
- 删除结点中“值等于某个特定值”的结点：
> 对于此种情况，不管是单链表还是双向链表，为了查找值等于给定值的结点（可能有多个），都需要从头结点考试一个个地遍历对比，直到找到符合条件的结点删除。  
> 虽然链表删除操作的时间复杂度为O(1)，但删除之前需要遍历查找（时间复杂度为O(n)）, 所以此种情况的链表删除操作时间复杂度为O(n)。
- 删除给定指针指向的结点：
> 这里我们已经知道了要删除的结点，但是删除某个结点q需要知道它的前驱结点。在单链表中，不支持直接获取前驱结点，为了找到前驱结点，还是需要从头开始遍历链表，知道p-next->q，才说明p是q的前驱结点。单链表删除时间复杂度为O(n)。  
> 对双向链表而言，双向链表的结点中已经保存了前驱结点的指针，所以并不需要像单链表一样去遍历一遍。针对这种情况的双向链表删除操作，时间复杂度为O(1)。

插入同理，双线链表**在指定结点前插入**一个结点，时间复杂度为O(1)，单链表为O(n)。

##### 查询
> 对于一个**有序链表**，双线链表的按值查询的效率也要比单链表高。因为有序，我们查询时可以记录上次查询的位置p，先比较查询值与p的大小关系，根据大小关系决定是往前查找还是往后查找，比起单链表，平均只需查找一半的数据。时间复杂度为O(n/2)=O(n)。 

LinkedHashMap的实现原理就又到了双向链表这种数据结构。

### 空间换时间的设计思想
> 在实际开发中，虽然双向链表比较费内存，但是使用还是比单链表更加广泛。当内存空间充足的时候，如果我们追求代码的执行速度，可以选择空间复杂度相对较高、但时间复杂度低的算法或者数据结构。反之是**时间换空间**的设计思想。

缓存的例子也是利用了空间换时间的设计思想。数据若是存在硬盘内，节省内存但是每次访问数据都要访问硬盘，比较耗时。通过缓存，查询一次之后将数据存在内存内，虽然耗费了内存空间，但是访问硬盘的时间大大减小了。

## 栈

当某个数据集合**只涉及在一端插入和删除数据，并且满足后进先出、先进后出的特性**，应该优先选择栈这个数据结构操作数据。

### 栈的实现

- 顺序栈：用数组实现的栈

```java
package com.example.algorithm;

import lombok.Data;

/**
 * @className: ArrayStack
 * @author: yang
 * @date: 2019/11/5
 */
@Data
public class ArrayStack {

    // 存放元素的素组
    private Object[] array;

    // 栈实际大小
    private int count;

    // 数组大小
    private int size;

    /**
     * 构造方法
     * @param size
     */
    public ArrayStack(int size) {
        this.array = new Object[size];
        this.count = 0;
        this.size = size;
    }

    /**
     * 栈顶入栈
     * @param obj
     * @return
     */
    public Object push(Object obj) {
        if (size > count + 1) {
            array[count] = obj;
            count++;
        } else {
            // 扩容
        }
        return obj;
    }

    /**
     * 栈顶出栈
     * @return
     */
    public Object pop() {
        Object obj = null;
        if (count > 0) {
            obj = array[count - 1];
            array[count - 1] = null;
            count--;
        }
        return obj;
    }
}

```

- 链式栈：用链表实现的栈

```java
/**
 * @className: LinkedStack
 * @date: 2019/11/5
 */
@Data
public class LinkedStack<E> {

    /**
     * 栈追上层节点
     */
    private Node<E> header;

    /**
     * Node节点个数
     */
    private int count;


    /**
     * Node内部类
     * @param <E>
     */
    @Data
    private static class Node<E> {
        /**
         * 节点值
         */
        private E item;
        /**
         * 尾节点
         */
        private Node<E> next = null;

        Node(E item) {
            this.item = item;
        }
    }

    public E push(E e) {
        if (header == null) {
            header = new Node<>(e);
        } else {
            Node<E> old = header;
            Node<E> newNode = new Node<>(e);
            newNode.setNext(old);
            header = newNode;
        }
        count++;
        return e;
    }

    public E peek() {
        if (header == null) {
            return null;
        }
        return header.item;
    }

    public E pop() {
        if (header == null) {
            return null;
        } else {
            E curItem = header.item;
            Node<E> nextHeader = header.next;
            header.setItem(null);
            header.setNext(null);
            header = nextHeader;
            count--;
            return curItem;
        }

    }

}
```



## 队列

## 哈希表

## 堆

## 二叉查找树