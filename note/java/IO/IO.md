# IO

IO操作主要是指使用Java进行输入、输出操作。

Java中所有的IO机制都是基于**数据流**进行输入输出，这些数据流表示了字符或者字节数据的流动序列。

Java的IO流提供了读写数据的标准方法。任何Java中表示数据源的对象都会提供流的方式读写它数据的方法。

Java.io是大多数面向数据流的输入、输出类的主要软件。此外，Java对块传输也提供支持，Java.nio采用的便是块IO。

## 基本概念

### 数据流

一组有序，有起点、有终点的数据序列。包括输入流和输出流。

![数据流](imgs/数据流.jpg)

采用数据流的目的就是使得输入输出独立于设备。

输入流不关心数据源来自于何种设备（键盘、文件、网络），输出流不关心数据的目的是何种设备。

![输入流输出流](imgs/InputStreamOutputStream.png)

### IO流的分类

1. 按照**流的流向**划分，可以把流分为：**输入流**和**输出流**。

- 输入流：程序从输入流**读取**数据源。数据源包括键盘、文件、网络等，即是将数据源读入到程序的通信通道。
- 输出流：程序向输出流**写入**数据，将程序中的数据输出到外界（显示器、打印机、文件、网络等）的通信通道。

这里的输入和输出都是从**程序运行所在内存**的角度来划分的。

2. 根据**操作单元**的不同分为：字符流和字节流。

- 字节流

  - 一次读入或者读出是8位二进制（一个字节）。

  - 字节流以字节为单位。
  - 字节流能处理所有类型的数据（图片，视频等都不在话下）
  - 字节流能处理字符数据

  > 字节是计算机中最小的数据单元。

  - 除文本数据之外的数据，优先考虑字节流

- 字符流

  - 一次读入或者读出是16位二进制（两个字节）。
  - 字符流以字符为单位，根据码表映射字符，一次可能读取多个字节
  - 字符流只能处理字符类型的数据
  - 字符流适合处理文本数据

3. 根据**流的角色**划分，可以分为**节点流**和**处理流**。

- 节点流：可以从一个特定的IO设备读数据（或者向一个特定的IO设备写数据）的流，节点流也被称为低级流。
- 处理流：用于对一个已存在的流进行连接和封装，通过封装后的流来实现数据的读、写功能，处理流也被称为高级流。

![节点流](imgs/节点流和处理流.jpg)

当使用节点流进行输入和输出时，程序直接连接到实际的数据源，和实际的输入、输出节点连接。

当使用处理流进行输入输出时，程序不会直接连接到数据源，没有和实际的输入、输出节点连接。使用处理流的好处是，**只要使用相同的处理流，程序就可以采用完全相同的输入、输出代码来访问不同的数据源，随着处理流所包装节点流的变化，程序实际所访问的数据源也相应的发生变化**。

![输入流](imgs/输入流.jpg)

![输出流和处理流模型](imgs/输出流和处理流模型.jpg)

输入流和输出流把水滴输入/输出后，会有一个隐式指针来表示水滴的位置（输入流指针表示即将读取的位置，输出流指针表示流即将放入的位置）。

如上图，处理流可以“嫁接”在任何已存在的流的基础之上，这就允许Java应用程序采用相同的代码，透明的方式来访问不同的输入和输出设备的数据流。

处理流较节点流而言，优点如下：

- 性能提高： 主要以增加缓冲的方式来提高输入输出效率
- 操作更便捷： 处理流提供了一系列便捷的方法允许一次性输入输出大批量的内容，而不是单个字符/字节

#### 

#### 输入输出流体系中常用的流的分类表

![流的分类](imgs/流的分类.png)



### 用户空间和内核空间

Linux将内存分为了用户空间和内核空间，只有内核空间可以直接调用硬件（磁盘、网卡等）。我们平时的用户进程一般是在用户空间，所以用户空间的进程要进行IO操作，需要与内核空间一起协作。

比如，读取数据操作需要进行以下两步：

1. 准备数据：把数据从硬件填充到内核空间的缓存里
2. 拷贝数据：把数据从内核空间复制到用户空间



### 同步和异步

同步和异步关注的是**消息通信机制**。更针对于被调用者。

- 同步：同步即是发起一个调用后，要等到调用完成（得到结果）后才返回。
- 异步：异步调用发起调用后立即得到被调用者的回应表示**已接收到请求**，但是**被调用者这时并没有返回结果**，此时我们可以处理其他请求，被调用者通常依靠事件、回调机制来通知调用者返回结果。

同步和异步最大的区别是**异步不需要等待被调用者的返回结果，并且异步会依靠事件、回调机制来通知调用者结果**。

Node.js使用的就是异步编程模型。

### 阻塞和非阻塞 

阻塞和非阻塞关注的是**程序在等待调用结果时的状态**。通俗来讲就是更针对于调用者。

- 阻塞：阻塞就是发起一个调用后，在被调用者返回结果之前，当前线程会**被挂起无法从事其他任务**，线程只有在得到结果后才会继续执行下去。
- 非阻塞：非阻塞是指发起一个调用后，该调用不会阻塞当前线程，当前线程不用一直等待结果返回，可以去执行其他任务。从表面上看非阻塞的方式能提高CPU的利用率，但是不要忘了这种方式会带来系统线程切换的增加。

### Linux中几种常见的IO模型

#### 同步阻塞

BIO模型图：

![BIO](imgs/同步阻塞IO.jpg)

当左边的进程发起“系统调用”后，kernel先进入第一个阶段“等待数据”；数据报准备好后再进入第二个阶段“拷贝数据”。BIO在上述两个阶段都是**阻塞**的。

#### 同步非阻塞

同步非阻塞模型图：

![非阻塞IO](imgs/非阻塞IO.jpg)

上图可以看出应用进程`recvfrom`总是立即返回的。

#### IO多路复用

IO多路复用通过一种机制，可监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。

IO多路复用技术就是为了解决线程阻塞到某个IO系统而出现的技术，使进程不阻塞于某个特定的IO系统调用。

IO复用模型：

![IO多路复用](imgs/IO多路复用.jpg)

select、poll函数介绍见[Linux I/O多路复用](https://www.linuxprobe.com/linux-io-multiplexing.html)。

epoll函数：

epoll函数是之前select和poll函数的增强版本，epoll函数较其他两个函数更加灵活，没有描述符限制。

epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的时间存放到内核的一个事件表中，这样在用户空间和内核空间的复制操作只需进行一次。

epoll对文件描述符的操作有两种模式：

- LT（level trigger）：默认模式。当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序可以不立即处理该事件。下次调用 epoll_wait 时，会再次响应应用程序并通知此事件。
- ET（edge trigger）：当 epoll_wait 检测到描述符事件发生并将此事件通知应用程序，应用程序必须立即处理该事件。如果不处理，下次调用 epoll_wait 时，不会再次响应应用程序并通知此事件。

epoll的优点：

1. 在select/poll中，进程只有在调用一定的方法后，内核才对所有监视的文件描述符进行扫描，而epoll事先通过epoll_ctl()来注册一个文件描述符，已在基于某个文件描述符就绪时，内核会采用类似callback的回调机制迅速激活这个文件描述符，当进程调用epoll_wait()时遍得到通知。 // todo 我也没看懂。
2. 监视的描述符数量不受限制，它所支持的FD上限是最大可打开的文件数目，一般远大于select支持的1024。
3. IO的效率不会随着监视fd数量的增长而下降。select和poll实现需要自己不断轮询所有的fd集合，直到设备就绪，期间睡眠和唤醒可能会多次交替。而epoll只需要调用epoll_wait()不断轮询就绪链表，期间也可能会有多次睡眠和唤醒的交替。但是 select() 和 poll() 在“醒着”的时候要遍历整个fd集合，而 epoll 在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的 CPU 时间。这就是回调机制带来的性能提升。
4. select、poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只需要一次拷贝，节省了不少的开销。



#### 信号驱动

信号驱动模型：

![信号驱动](imgs/信号驱动.jpg)

#### 异步IO

异步IO模型：

![异步IO](imgs/异步IO.jpg)

#### 五种模型对比

![Linux五种io模型对比](imgs/Linux五种IO模型对比.jpg)



## Java中的IO模型

### BIO

Blocking I/O，同步阻塞模式的IO，数据的读取和写入必须阻塞在一个线程内等待其完成，效率较低。

Java IO流的40多个类都是从如下4个抽象类基类中派生出来的：

- **`InputStream/Reader`**:所有输入流的基类，InputStream是字节流，Reader是字符流。
- **`OutputStream/Writer`**:所有输出流的基类，OutputStream是字节流，Writer是字符流。

#### 应用

Tomcat使用多线程+BIO来实现web server。

数据库连接池使用线程池+BIO来实现。

#### 实践 todo

### NIO

New I/O，同步，同时支持阻塞与非阻塞模式，主要使用非阻塞，从Java1.4中引入，对应`java.nio`包，提供了`Channel`、`Selector`、`Buffer`等接口或抽象方法。

#### Buffer

Java NIO Buffers用于和NIO Channel交互。通常是从Channel中读取数据到Buffer里，或者从Buffer把数据写入到Channel里。

Buffer本质上就是一块内存区域。

Buffer的三个关键属性：

- capacity
- position
- limit

Buffer有对应除了布尔类型的其他七种基本数据类型的实现：ByteBuffer、CharBuffer、ShortBuffer、IntBuffer、 LongBuffer、FloatBuffer、DoubleBuffer。除此之外还有MappedByteBuffer、HeapByteBuffer、DirectByteBuffer等相对复杂的实现。

- HeapByteBuffer：该Buffer的内存空间在 JVM 的 heap（堆）上分配，可以看做是 jdk 对于 byte[] 数组的封装
- DirectByteBuffer：直接利用系统接口进行内存申请，其内存分配在c heap中，减少了内存之间的拷贝操作，在使用DirectByteBuffer时，系统等于是直接从内存将数据写入到Channel中，无需进行Java堆的内存申请。

为什么不直接使用 DirectByteBuffer，还要来个 HeapByteBuffer？

> DirectByteBuffer 是通过full gc来回收内存的，DirectByteBuffer会自己检测情况而调用 system.gc()，但是如果参数中使用了 DisableExplicitGC 那么就无法回收该快内存了，-XX:+DisableExplicitGC标志自动将 System.gc() 调用转换成一个空操作，就是应用中调用 System.gc() 会变成一个空操作，那么如果设置了就需要我们手动来回收内存了，所以DirectByteBuffer使用起来相对于完全托管于 java 内存管理的Heap ByteBuffer 来说更复杂一些，如果用不好可能会引起OOM。Direct ByteBuffer 的内存大小受 -XX:MaxDirectMemorySize JVM 参数控制（默认大小64M），在 DirectByteBuffer 申请内存空间达到该设置大小后，会触发 Full GC。

#### Channel

Channel和IO中的Stream差不多是一个等级，只不过IO中的流是单向的，而Channel是双向的，可读可写。

NIO中的Channel的主要实现有：FileChannel、DatagramChannel、SocketChannel、ServerSocketChannel，分别对应文件IO、UDP和TCP（Server和Client）。

#### Selector

选择器，也可以称为多路复用器。用于检查一个或多个NIO Channel的状态是否处于可读或可写。Selector 运行单线程处理多个 Channel，如果应用打开了多个通道，而且每个的连接的流量都很低，使用Selector就是很好的选择。

在NIO中，通过对Selector的使用，可以用更少连接来处理channel，降低了上下文切换带来的开销。

#### 实践 todo

### AIO

AIO是在Java 7中引进的NIO改进版，是异步非阻塞的IO模型。异步是基于事件和回调机制实现，数据准备好了通知调用者（在NIO中需要通过轮询来确定是否有数据准备好可读可写）。

# 参考

- [深入分析 Java I/O 的工作机制](https://www.ibm.com/developerworks/cn/java/j-lo-javaio/index.html)
- [Linux和Java的I/O模型](https://yasinshaw.com/articles/52)
- [怎样理解阻塞非阻塞与同步异步的区别？](https://www.zhihu.com/question/19732473)
- [[Linux I/O多路复用](https://www.linuxprobe.com/linux-io-multiplexing.html)]
- [java IO体系的学习总结](https://blog.csdn.net/nightcurtis/article/details/51324105)

  