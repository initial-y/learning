# JVM	

## Java内存运行时数据区域 

Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为如下几个不同的数据区域。这些区域都有各自的用途及创建和销毁的时间，有的区域随着虚拟机进程的启动而存在（比如堆），有些区域则依赖用户线程的启动和结束来进行建立和销毁操作（比如Java虚拟机栈，本地方法栈）。

![java内存区域](./imgs/JVM内存区域.png)

### 程序计数器（PC寄存器）

程序计数器是一块较小的内存空间，它可以看做是当前线程所执行的字节码的行号指示器。

字节码解释器工作时，通过改变程序计数器的值来选取下一条需要执行的字节码指令。分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个程序计数器。

程序计数器所在内存区域是**唯一一个**在Java虚拟机规范中没有规定任何`OOM`情况的区域。

#### 程序计数器线程私有的原因

 Java虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的。在任一个确定时刻，一个处理器都只会执行一条线程中的命令。因此，为了保证各个线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

#### 程序计数器的值

如果线程正在执行的是一个Java方法，计数器记录的是正在执行的虚拟机字节码指令的地址。

如果线程正在执行的是Native方法，计数器的值为空（Undefined）。

> Native方法是Java通过JNI直接调用本地C/C++库。
>
> 可以认为Native方法相当于C/C++暴露给Java的一个接口，Java通过调用接口进而调用到C/C++方法，由于该方法通过C/C++实现，无法产生相应的字节码。并且C/C++执行时的内存分配是由C/C++语言本身决定的，不由JVM决定。

### Java虚拟机栈（Java方法栈）

Java虚拟机栈（Java Virtual Machine Stacks）是**线程私有**的，它的生命周期与线程相同。

Java虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行的同时都会创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。**每一个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中入栈到出栈的过程**。

#### 局部变量表

局部变量表存放了**编译期**可知的各种**基本数据类型**（int、float、double、long，byte、short、boolean、char）、**对象引用**（reference类型，不等同于对象本身，可能是一个指向对象起始地址的指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和**returnAddress类型**（指向一条字节码指令的地址）。

64位的long和double类型的数据会占2个局部变量空间（Slot），其余数据类型只占用1个空间。

**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在帧中分配多大的局部变量空间**完全是确定的**，在方法运行期间不会改变局部变量表的大小。

#### 操作数栈

操作数栈（Operand Stack）也常被称为操作栈，它是一个后入先出栈（LIFO）。

同局部变量表一样，操作数栈的最大深度也是在编译期确定（写入到方法Code属性的max_stacks数据项中）。

操作数栈的每一个元素可以是任意Java数据类型，32位的数据占用一个栈容量，64位的数据占用两个栈容量。

栈帧在刚刚创建时，操作数栈是空的。Java虚拟机提供的一些字节码指令会从局部变量表或者对象实例的字段中复制常量或变量值到操作数栈中，也提供了一些执行令用于从操作数栈取走数据、操作数据以及把操作结果重新入栈。

总之，如果一个变量想要被执行，就要加入到操作数栈中。

#### 动态链接

在一个class文件中，一个方法想要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。

Java虚拟机栈中，每个栈帧都包含一个**指向运行时常量池中该栈所属方法**的符号引用，持有这个引用的目的是为了支持方法调用过程中的**动态链接（Dynamic Linking）**。

静态解析与动态链接：

- 上面所说的符号引用一部分会在**类加载阶段或者第一次使用时**就直接转化为直接引用，这类转化被称为**静态解析**；
- 另一部分将在每次**运行期间**转化为直接引用，这类状态被称为**动态链接**

#### 方法出口

指的是方法执行后下一步指令的地址。

方法正常完成时，则根据当前方法返回的字节码指令返回给调用者（具体是否有返回值及返回值的数据类型根据该方法返回的指令决定）；发生异常时，只要在本方法的异常表中没有搜索到相应的异常处理器，就会导致方法退出。

无论方法是怎样退出的，在方法退出后都需要返回到方法被调用的位置，程序才能继续执行下去，因此方法返回时可能需要在当前栈帧中保存一些信息来帮它恢复到上层方法的执行状态。

方法退出的过程实际上就等同于将当前栈帧出栈，因此退出方法可能的操作有：恢复上层方法的局部变量表和操作数栈，把返回值压入调用者的操作数栈中，调整程序计数器的值以指向方法调用后的下一条指令。

一般来讲，要是方法正常退出，调用者的程序计数器的值可作为返回地址，栈帧中可能会保存这个计数值；方法异常退出时，返回地址是通过异常处理器决定的，栈帧中一般不会保存这个值。

#### 异常情况

在Java虚拟机栈中规定了两种异常情况：

- `StackOverflowError`异常：如果线程请求的栈深度大于虚拟机所允许的深度，抛出此异常；
- `OutOfMemoryError`异常：如果虚拟机栈可以动态扩展（大部分Java虚拟机都支持动态扩展，也允许固定长度的虚拟机栈），如果扩展时无法申请到足够的内存，就会抛出OOM异常。

### 本地方法栈

本地方法栈的作用与Java虚拟机栈相似，唯一的区别是：Java虚拟机栈为虚拟机执行Java方法（字节码）服务，而本地方法栈则为虚拟机使用的`native`方法服务。

虚拟机规范中对本地方法栈中方法的使用语言、使用方式以及数据结构并没有强制的规定，所以不同的虚拟机可以自由的实现。有的虚拟机（比如Sun公司的Hotpot虚拟机）直接将本地方法栈和Java虚拟机栈合二为一。

#### 异常情况

与Java虚拟机栈一样，本地方法栈区域也会抛出`StackOverFlowError`和`OutOfMemoryError`。

### 堆	

Java堆（Java Heap）是被所有线程共享的一块内存区域，在虚拟机启动时创建。通常来说，Java堆是Java虚拟机所管理的内存中最大的一块。

Java堆的**唯一目的**就是存放对象实例，几乎所有的对象实例都在这里分配内存（未逃逸对象在栈上分配）。

#### 垃圾回收堆的划分

Java堆是垃圾回收管理的主要区域，所以有时候Java堆也被称为“GC堆”。

从内存回收的角度来看，由于现在收集器基本都采用分代收集的算法，所以Java堆可以细分为：新生代和老年代。再细致一点可以分为Eden空间、From Survivor空间、To Survivor空间等。

从内存分配的角度来看，线程共享的Java堆可以划分出多个线程私有的分配缓冲区（Thread Local Allocation Buffer）。

总的来说，不管Java堆怎么划分，堆中存储的内容都是对象实例。划分的目的是为了更好的进行内存回收。

#### 异常

如果在堆中没有完成实例分配，并且堆也无法扩展时，会抛出`OutOfMemoryError`异常。

### 方法区

方法区（Method Area）是各个线程共享的内存区域。它用于存储已被虚拟机加载的类信息、常量、静态变量以及即时编译器编译后的代码等数据。

方法区有一个别名是Non-Heap。

方法区也常常被称为”永久代“（Permanent Generation），其实方法区与永久代并不等价，只是因为HotSpot虚拟机选择吧GC分代收集扩展至方法区而已。事实上，GC行为在这个区域是比较少出现的，此区域的内存回收目标主要是针对常量池的回收和对类型的卸载。此外，此区域的回收效率并不高，比如对类型的卸载回收的条件非常苛刻。

#### 运行时常量池

运行时常量池（Runtime Constant Pool）是方法区的一部分。

Class文件中除了有类的版本、字段、方法、接口等描述信息之外，还有一项是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在**类加载后**进入方法区的运行时常量池存放。

运行时常量池与Class文件常量池相比还有另一个特征：运行时常量池具有动态性，Java语言并不要求常量一定要在编译器产生。除开预置入Class文件中常量池的内容之外，运行期间也能将新的常量放入常量池中（用的比较多的比如String类的intern()方法）。

#### 异常

根据Java虚拟机的规范，当方法区无法满足内存分配需求时，会抛出`OutOfMemoryError`异常。

## 直接内存

直接内存（Direct Memory）不属于虚拟机运行时数据区域，也不属于Java虚拟机规范中定义的内存区域。但这部分内存会被频繁使用，而且也可能导致OOM异常。

直接内存不会受到Java堆大小的闲置，会受到本机总内存（包括RAM及SWAP区等）的限制。

### 直接内存的应用

在JDK1.4中加入的`NIO`（New Input/Output）类，引入了一种基于通道（Channel）和缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配**堆外内存**，然后通过一个存在Java堆中的`DirectByteBuffer`对象作为这块内存的引用进行操作。这类操作能避免Java堆和Native堆中来回复制数据，在有些场景能显著提高性能。

## 垃圾回收

垃圾回收（Garbage Collection）是Java虚拟机垃圾收集器提供的用于在空闲时间不定时回收无任何对象引用的对象所占据空间的一种机制。

### 判断对象是否已死

垃圾收集器在对堆进行垃圾回收之前，第一件事情就是要确定堆中的对象哪些还活着，哪些已死去。

#### 引用计数法

引用计数法（Reference Counting）是给每个对象添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1，反正当引用失效时这个值就减一。所以，任何时刻计数器的值为0的对象就是不能被使用的对象。

引用计数法实现简单，判定效率也很高，但Java虚拟机并没有选用引用计数法来管理内存，其中最重要的原因是：**引用计数法很难解决对象之间的循环引用**。

```java
Object objA = new Object();
Object objB = new Object();
objA.instance = objB;
objB.instance = objA;
objA = null;
objB = null;
System.gc();
```

如果Java虚拟机使用引用计数法来管理内存，那么上面代码中的objA和objB就不会被回收，事实上运行上述代码这两个对象是会被回收的，侧面反映了Java虚拟机并不是使用引用计数法来判断对象是否存活的。

#### 可达性分析算法

可达性分析算法（Reachability Analysis）的基本思路是通过一系列被称为`GC Roots`的对象作为起点，从这些节点开始向下搜索，搜索所走过的路径被称为**引用链**（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明这个对象是不可用的。

![GcRoots引用链](./imgs/GcRoots引用链.jpg)

从上图可以看出，右侧object5，6，7虽然相互有关联，但是它们的关联并不是以GC Roots为起点，所以在进行垃圾回收时它们会被判定为可回收的对象。

##### GC Roots

- 虚拟机栈中（栈帧中的本地变量表）引用的对象
- 本地方法栈中JNI（native方法）引用的对象
- 方法区中类静态属性引用的对象
- 方法区中常量引用的对象

栈的生命周期是跟着线程走的，栈中引用对象一般不收GC管理。方法区中引用的对象一般为不可变或者持久的，一般不依赖于某个对象实例。所以作为GC Root是的对象有稳定可靠的特性。

#### 引用

可达性分析算法和引用计数法判断对象是否存活都与引用有关。

在JDK1.2之后，Java堆引用的概念进行了扩充，将引用分为如下4种：

- 强引用（Strong Reference）。强引用是指在程序代码中普遍存在的，类似于`Object obj = new Objcet()`之类的引用。只要强引用还在，垃圾收集器永远不会回收被引用的对象。
- 软引用（Soft Reference）。软引用是用来描述一些还有用但非必需的对象。对于软引用关联着的对象 ，在系统将要发生内存溢出异常之前，将会把这些对象列入回收范围进行第二次回收。如果这次回收还没有足够的内存，才会抛出OOM异常。在JDK1.2之后，提供`SoftReference`类来实现软引用。
- 弱引用（Weak Reference）。弱引用也是用来描述非必需的对象，它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾回收之前。当下一次垃圾收集发生之前，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，`WeakReference`类用来实现软医用。
- 虚引用（Phantom Reference）。虚引用也被称为幽灵引用或幻影引用，它是所有引用中最弱的一种引用关系。一个对象是否有虚引用存在，完全不会对这个对象的生存时间造成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的**唯一目的**是：在这个对象被收集器回收时能收到一个系统通知。Java中通过`PhantomReference`来实现虚引用。

---

## Java代码是怎么运行的

### JRE与JDK

- JRE仅包含Java程序的必须组件，包括**Java虚拟机**以及**Java核心类库**等。
- JDK除了包含JRE之外，还附带了一系列开发、诊断工具。

### Java代码为什么要在虚拟机里运行

编译器将Java程序转换成Java虚拟机能识别的**指令序列**，这个指令序列也称为**Java字节码**。

好处之一是它的**可移植性**。一个Java程序一旦被转换成Java字节码，那么就可以在不同平台的虚拟机里运行。这就是常说的“一次编译，到处运行”。

虚拟机的一个好处就是它带来一个**托管环境（Managed Runtime）**。这个托管环境能代替我们处理一些代码中冗长切容易出错的部分。比如：**自动内存管理**与**垃圾回收**。此外，托管环境还提供了比如数组越界、动态类型、安全权限等动态检测，使我们免于书写很多与逻辑无关的代码。

### Java虚拟机如何运行Java字节码

![JVM](https://static001.geekbang.org/resource/image/ab/77/ab5c3523af08e0bf2f689c1d6033ef77.png)

以HotSpot虚拟机为例。

先将Java代码编译成class文件。再将.class文件加载到Java虚拟机中。

加载后的Java类会被存放于**方法区（Method Area）**中。所以，实际运行时会先执行方法区中的代码。

Java虚拟机在内存中划分出**堆**和**栈**来存储**运行时数据**。Java虚拟机将栈划分**Java方法栈（面向Java方法）**和**本地方法栈（c++，native方法，面向本地方法）**。

PC寄存器用来存放各线程的执行位置。

在运行过程中，当程序调用进入一个Java方法，虚拟机都会在当前线程的Java方法栈中生成一个**栈帧**，用来存放**局部变量**以及**字节码的操作数**。Java虚拟机不需要栈帧在内存里连续分布。

线程退出执行的当前方法时，不管是否正常返回，Java虚拟机都会弹出当前线程的栈帧并舍弃。

### 解释执行和即时编译（JIT，just-in-time）

Java字节码不能被计算机直接执行，Java虚拟机需要将字节码翻译成计算机可以识别的**机器码**。

解释执行：逐条将字节码翻译成机器码。解释执行的优势是无需等待编译。

即时编译：将一个方法中包含的所有字节码编译成机器码后再执行。即时编译的优势是经过编译后，实际运行速度会更快。

HotSpot采用混合模式：先执行字节码，然后将反复执行的热点代码以方法为单位进行即时编译。

![解释执行和即时编译](https://ss.csdn.net/p?https://mmbiz.qpic.cn/mmbiz_png/sG1icpcmhbiaCtVIq4Wt5FU2JYOsbo6sHKqdMZF9PawtrzbHLib0X9PhPKtgfMbtOeIv3JoH5HTGFyiaKeUR0tCiaaA/640?wx_fmt=png)

### JVM的运行效率

即时编译是JVM提升启动性能和峰值性能的重要技术之一。

Hotspot内置多个即时编译器：C1、C2和Graal。引入多个编译器的原因是为了方便在编译时间和生成代码的执行效率之间做出取舍。

C1编译器，又叫Client编译器。编译时间较短，面向对启动性能有要求的客户端GUI程序，采用的优化手段相对简单。

C2编译器，又叫Server编译器。编译时间相对较长，但生成的代码执行效率较高。主要面向对峰值性能有高要求的服务端程序，采用的优化手段相对复杂。

从Java7开始，Hotspot默认采用分层编译的方式编译字节码：热点方法先被C1编译，然后热点方法中的热点进一步被C2编译。

Hotspot的即时编译放在额外的编译线程中进行。一般是1:2的配比配置C1和C2。

在计算资源充足的情况下，字节码的解释执行和即时编译和同时进行。编译完成后机器码会在下次调用该方法时启用，替换原本的解释执行。



## Java 虚拟机加载Java类

从class文件内存中的类，按先后顺序需要经过**加载、链接和初始化**三大步骤。

Java语言类型：

- 基本类型：Java虚拟机预先定义好。
- 引用类型
  - **类**：有对应的字节流。
  - **接口**：有对应的字节流。
  - **数组类**：由Java虚拟机直接生成。
  - 泛型参数：泛型参数在编译过程中会被擦除。



**字节流**最常见的形式是由Java编译器生成的class文件。此外，我们也可以在程序内部直接生成，或者从网络中获取字节流。不同形式的字节流，会被加载到Java虚拟机中，成为类或者接口。

无论是直接生成的数组类，还是加载后的类，Java虚拟机都需要对这些类进行链接和初始化。

### 加载

加载，指的是查找字节流并且以此创建类的过程。数组类没有对应的字节流，由Java虚拟机直接生成；而其他的类和接口，Java虚拟机需要借助类加载器来完成查找字节流的过程。

启动类加载器，boot class loader，由c++实现，没有对应的Java对象，在Java中只能用null替代。启动类加载是其他类加载器的“祖师爷”。

除了启动类加载器之外，其他的类加载器都是`java.lang.ClassLoader`的子类，这些类加载器有对应的Java对象。这些类加载器先要由另一个类加载器加载至Java虚拟机中才能执行类加载。

在Java9之前，启动类加载器负责加载最基础最重要的类，比如放在JRE的lib目录下jar包中的类。除了启动类加载器之外，**扩展类加载器**（extension class loader）和**应用类加载器**（application class loader）也是很重要的类加载器，这两个加载器均有Java核心类库提供。

扩展类加载器的父类是启动类加载器。它负责加载相对次要但又通用的类。

应用类加载器的父类加载器则是扩展类加载器。它负责记载应用程序路径下的类。

> 应用程序路径，指的是虚拟机参数 -cp/-classpath、系统变量 java.class.path 或环境变量 CLASSPATH 所指定的路径。

Java9引入了模块系统，把扩展类加载器改为了**平台类加载器**（platform class loader）。Java SE中除了少数几个关键模块（比如Java.base），其他模块都是由平台类加载器加载。

除了Java核心类库提供的类加载器，我们可以加入自定义类加载器来实现特殊的加载方式。比如，可以对class文件加密，在用自定义的类加载器解密。

除了加载，类加载器还提供了命名空间的作用。

在Java虚拟机中，类的唯一性是由类加载器实例以及类的全名一同确定。即使是同一串字节流，由不同的类加载器加载，也会得到两个不同的类。在大型应用中我们常利用这一特性来运行同一个类的不同版本。

#### 双亲委派模型

每当一个类加载器接收到加载请求时，它会将请求转发给父类加载器。在它的父类加载器没有找到所请求的类时，该类才会尝试去加载请求类。

### 链接

链接，指的是将创建好的类合并至Java虚拟机中，使之能够执行的过程。

链接可分为**验证、准备以及解析**三个阶段。

- 验证阶段：目的在于确保被加载的类能够满足Java虚拟机的约束条件。通常而言Java编译器生成的类文件必然满足Java虚拟机的约束条件。

- 准备阶段：为被加载类的静态字段分配内存。

  > Java代码中对静态字段的初始化会在后面的初始化阶段中进行。
  >
  > 除了分配内存之外，部分Java虚拟机还会在此阶段构造其他跟类层次相关的数据结构，比如用来实现虚方法的动态绑定的方法表。

- 解析阶段：非必须， 将符号引用解析成实际引用。如果符号引用指向一个未被加载的类，或者未被加载类的字段和方法，那么解析将触发这个类的加载。（注意 未必会触发这个类的链接和初始化）

  > 在 class 文件被加载至 Java 虚拟机之前，这个类无法知道其他类及其方法、字段所对应的具体地址，甚至不知道自己方法、字段的地址。因此，每当需要引用这些成员时，Java 编译器会生成一个**符号引用**。在运行阶段，这个符号引用一般都能够无歧义地定位到具体目标上。
  >
  > 举例来说，对于一个方法调用，编译器会生成一个包含目标方法所在类的名字、目标方法的名字、接收参数类型以及返回值类型的符号引用，来指代所要调用的方法。

### 初始化

类加载的最后一步便是初始化。目的是为常量值的字段赋值，以及执行<clinit>方法的过程。Java虚拟机会通过加锁来确保类的<clinit>方法仅被执行一次。

只有当初始化完成后，类才正式成为可以执行的状态。

在Java中，要初始化一个静态字段，恶意在声明时直接赋值，也可以在静态代码块中对其赋值。

如果直接赋值的静态字段被final修饰，并且它的类型是基本类型或字符串时，那么该字段会被Java编译器标记成**常量值**（ConstantValue），常量值的初始化直接由Java虚拟机完成。

除常量值之外的其他直接赋值操作，及所有静态代码块中的代码，会被Java编译器置于同一方法中，并把它命名为<clinit>。

类的初始化何时被触发：

1. 当虚拟机启动时，初始化用户指定的主类；
2. 当遇到用以新建目标类实例的 new 指令时，初始化 new 指令的目标类；
3. 当遇到调用静态方法的指令时，初始化该静态方法所在的类；
4. 当遇到访问静态字段的指令时，初始化该静态字段所在的类；（单例延迟初始化）
5. 子类的初始化会触发父类的初始化；
6. 如果一个接口定义了 default 方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；
7. 使用反射 API 对某个类进行反射调用时，初始化这个类；
8. 当初次调用 MethodHandle 实例时，初始化该 MethodHandle 指向的方法所在的类。

## JVM如何执行方法调用

### 重载与重写

- 重载：同一类中名字相同，参数类型不同的方法，方法之间的关系称之为重载。
- 重写：子类定义了与父类方法中非私有方法同名的方法，并且这两个方法参数类型相同，那么这两个方法之间的关系是重写。

### JVM的静态绑定和动态绑定

#### 虚拟机识别方法

虚拟机识别方法关键在于**类名、方法名和方法描述符（method decriptor）**。

> 方法描述符，由方法的参数类型及返回类型构成。
>
> 在同一个类中如果出现多个名字相同并且方法描述符也相同的方法，Java虚拟机会在类的验证阶段报错。
>
> > 注意，编译阶段也会报错。

## Java垃圾回收

垃圾回收：将已经分配出去但不再使用的内存回收回来，以便能再次分配。

### 引用计数法与可达性分析

#### 引用计数法

为每个对象添加一个引用计数器，用来统计指向该对象的引用个数。

> 一旦某个对象的引用计数器为0，表明该对象已经死亡，可以被垃圾回收。
>
> 引用计数法弊端：
>
> - 需要额外的空间来存储计数器
> - 更新繁琐
> - 无法处理循环引用的对象（循环引用的对象所占据的空间不可回收，易造成内存泄漏）

#### 可达性分析算法

将一系列GC Roots作为初始的存活对象的集合，然后从该集和触发，探索所有能被该合集所引用到的对象，并将其假如到该集合中，这个过程我们称之为**标记（mark）**。最终未被探索到的对象即是死亡的，可被垃圾回收。

GC Roots：由堆外指向堆内的引用。

GC Roots包括但不限于以下几种：

- Java方法栈帧中的局部变量
- 已加载类的静态变量
- JNI handles
- 已启动且未停止的Java线程

可达性分析可以解决引用计数法不能解决的循环引用的问题。假如a、b相互引用，只要从GC Roots出发无法到达a或b，那么可达性分析就不会将他们加入存活的对象集合中。

可达性分析弊端：

多线程环境下，其他线程可能会更新已经访问过的对象中的引用，从而将引用设置为null（误报），或者将引用设置为未被访问过的对象（漏报）。

误报相对不那么严重，Java虚拟机最多损失了部分垃圾回收的机会。

漏报的情况，GC可能会回收事实上仍然被引用的对象内存。如果原引用访问已被回收的对象，很有可能会导致Java虚拟机崩溃。

#### stop-the-world

在Java虚拟机中，传统的垃圾回收算法采用的是Stop-the-world方法：停止其他非垃圾回收线程的工作，知道完成垃圾回收。

Stop-the-world造成了垃圾回收的暂停时间（GC pause）。

#### 如何判断一个对象是否死亡



## 参考

- 深入理解Java虚拟机

  



